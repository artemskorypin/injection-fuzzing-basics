# Command Injection wordlists

Словари для обнаружения и фаззинга **командных инъекций** (OS Command Injection) на Unix и Windows.

Общий принцип всего репозитория:

> **одна строка = один payload**, минимум дубликатов, фокус на идеях/техниках.

---

## Файлы

### `shell-delimiters.txt`

Разделители и операторы оболочки:

- `;`, `&&`, `||`, `|`, переводы строк, URL-encoded варианты и т.п.
- Используются для проверки, можно ли **разорвать** исходную команду и дописать свою.

Часто комбинируется с другими словарями (`command-execution-*`, `OSCommandInject-*`).

---

### `command-execution-unix-id.txt`

Нагрузки для Unix, ориентированные в первую очередь на **идентификацию / базовый детект**:

- различные способы вызвать `id` (и похожие команды) с разными разделителями, кавычками, SSI, `system('id')` и т.д.
- цель: *минимальной командой* показать, что инъекция существует (кто выполняет команду, под каким пользователем).

Полезен как «легкий» детект-словарь.

---

### `command-execution-unix.txt`

Более широкий Unix-набор:

- `id`, `uname -a`, `ls`, `cat /etc/passwd`, `ping` (в том числе time-based),
- варианты через `system()`, SSI (`<!--#exec cmd="..."-->`) и т.п.

Идея: быстрая разведка окружения после того, как инъекция уже подозревается/подтверждена.

---

### `command-execution-unix-nospaces.txt`

Unix-пейлоады **без пробелов** или с нестандартными разделителями:

- использование `${IFS}`, brace expansion (`{cmd,arg}`),
- перенаправления (`cat</etc/passwd`),
- ANSI-C quoting (`X=$'id';$X`),
- табы / `%09` вместо пробелов.

Нужен, когда фильтруются пробелы/определённые символы, но сам факт выполнения команды возможен.

---

### `command-execution-unix-oob.txt`

Небольшой набор для **blind / out-of-band** детекта на Unix:

- `nslookup/host/dig` на контролируемый домен,
- `curl/wget` с отправкой результата команды в запрос,
- `ping` на внешний хост.

Использовать, когда:

- ответ приложения ничего не показывает,
- но ты контролируешь DNS/HTTP-логи и можешь отследить вызов.

В строках используется плейсхолдер вида `YOURCOLLABID.example.com` — его нужно заменить на свой домен/хост.

---

### `OSCommandInject-Windows.txt`

Базовые payload’ы для Windows:

- варианты с `dir C:\`, просмотр каталогов/файлов,
- разные формы кавычек/слэшей, комбинации с `&`, `&&` и т.п.

Подходит для начальной проверки Windows-контекстов.

---

### `OSCommandInject-Windows-bypass.txt`

Windows-пейлоады для **обхода фильтров**:

- трюки с переменными окружения и substring-синтаксисом (`%PROGRAMFILES:~start,len%`, `%SystemRoot:~0,3%`),
- позволяют «собрать» куски вроде `C:\` или слэши, даже если их пытаются фильтровать.

Используется, когда:

- есть сигнал о командной инъекции, но прямые `dir C:\` / `type C:\boot.ini` режутся,
- нужно проверить, можно ли обойти фильтрацию именно на уровне строки.

---

## Использование

- Любой файл можно подключить к сканеру/фаззеру (ZAP, Burp и т.п.) как **payload list**.
- Типичный сценарий:
  1. Сначала попробовать разделители (`shell-delimiters.txt`) + лёгкие `id`-payload’ы (`command-execution-unix-id.txt` / `OSCommandInject-Windows.txt`).
  2. Если есть признаки инъекции — подключать расширенные списки (`command-execution-unix.txt`, `*-nospaces.txt`).
  3. Для blind-кейсов использовать `command-execution-unix-oob.txt` и аналоги под Windows (можно адаптировать вручную).
- В словарях представлены «разведочные» команды вроде `id`, `whoami`, `uname`, что укаладывается в идею репозитория: **сначала детект и минимальная разведка, потом уже тяжёлые вещи из внешних источников.**

