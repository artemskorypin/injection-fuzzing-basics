XSS-JSB.txt — JS Breaks (разрывы JS-контекста)

Что это: набор коротких payload’ов, которые рассчитаны на инъекцию внутрь JavaScript-кода: в строку, выражение, массив, объект, либо после ; в inline-скрипте.
Цель — «вырваться» из текущего JS-контекста и выполнить свой код.

Типовые под-контексты, которые покрывает файл:

JS expression / inline script:
alert(1), +alert(0)+

Выход из строк/комментариев/шаблонов:
';// ..., '}; ...

Разрывы массивов/объектов:
1]; ..., ']; ..., 1}; ...

Мини-обфускация через eval/alias:
a=eval;b=alert;a(b(...))

Event-атрибут под JS, если значение прямо подставляется:
xyz onerror=alert(6); (это скорее «JS-внутри-атрибута», но всё ещё JS-контекст)

Где особенно полезно фаззить:

script-блоки, куда сервер/DOM подставляет данные без экранирования

inline-обработчики типа onclick="USER_INPUT"

DOM-sinks: eval, setTimeout(string), Function, location→eval, небезопасные шаблонизаторы

Идея тега: DOM/JS_CONTEXT_BREAKOUT.

XSS-JSN.txt — JSON / onload-JS контексты

Что это: payload’ы, которые «ломают» JSON-подстановку или JS-объекты, часто через onload=/event-handlers или через вставку переменных в JSON-литералы.
Они похожи на JSB, но акцент на то, что данные сидят в структуре (JSON/объект), а не просто в выражении.

Какие кейсы покрывает:

JSON/объектная подстановка:
инъекции, где ввод попадает в { "key": "USER_INPUT" } или var x = USER_INPUT;

onload / body-синк:
<body onload=...> варианты, где ввод вставлен в обработчик

Структурные обходы парсера:
через лишние ;, {}, странные body/s/onload=..., «разъезд» тегов/атрибутов

Где фаззить:

страницы, где сервер рендерит JSON прямо в HTML (<script>var cfg = {...}</script>)

шаблоны SPA, где значения из URL/Storage попадают в JSON→eval/innerHTML

любые DOM-цепочки вида JSON.parse(userInput) → потом значение идёт в опасный sink

Идея тега: DOM/JSON_OR_OBJECT_CONTEXT.
